### 紀錄內容：

今天遇到一種問題是如果API的responseType是arraybuffer，這種型態用於下載檔案，回傳的是Blob的形式
```javascript!
// api list
// 下載報告
export const getReportDownload = async (id: string): Promise<any> => {
  return await request({
    method: 'get',
    url: `/report/download/${id}`,
    responseType: 'arraybuffer',
  })
}
```

頁面端解析:
```javascript!
// page的部分
const downloadPdf = async (id: string): Promise<void> => {
  isLoading.value = true
  await getReportDownload(id).then((res) => {
    const blob = new Blob([res.data], { type: res.headers['content-type'] });
    var URL = window.URL || window.webkitURL;
    let href = URL.createObjectURL(blob);
    window.open(href) // 另開新分頁
  }).catch((error) => {
    message.error(error)
  }).finally(() => {
    isLoading.value = false
  })
}
```

如果今天遇到這種API的錯誤訊息，會把後端原有的錯誤訊息內容(error.response.data)也回傳arraybuffer的型態，此時可以解析後再回傳錯誤訊息

```javascript!
// axios
axiosRequest.interceptors.response.use(
  ...
  async (error) => {
    const { config, response, request } = error;
    let errorMessage = error.message
    if (error.response.data) {
      // 先判斷型態是否為ArrayBuffer，若是則解析完再繼續
      let errorData = error.response.data
      if (config.responseType === 'arraybuffer' && error.response.data instanceof ArrayBuffer) {
        const decoder = new TextDecoder('utf-8');
        const text = decoder.decode(new Uint8Array(errorData));
        errorData = JSON.parse(text)
      }
      // 判斷是否有錯誤描述(error_desc)
      if (errorData.error_desc) {
        ...
        errorMessage = errorData.error_desc  
      }

    throw errorMessage;
  }
)
```